\lhead{\emph{\leftmark}}  % Set the left side page header to "Abbreviations"
\chapter{Background}
\label{chap:background}

This chapter presents the required background knowledge for readers to fully understand the following chapters. We introduce the Umple language and we present the most important concepts about model-to-model transformations and some of the most relevant reverse engineering techniques. 
\section{Umple Modeling Language}

Umple \cite{UmpleMAIN} is an open-source textual modeling and programming language that adds UML abstractions to base programming languages including Java, PHP, C++ and Ruby.\\
Umple has been designed to be general purpose and has UML class diagrams and UML state diagrams as its central abstractions. It has state-of-the art code generation and can be used incrementally, meaning that it is easy for developers to gradually switch over to modeling from pure programming. Umple was designed for modeling and developing large systems and for teaching modeling \cite{teachingUmple}. Umple is written in itself – the original java version was manually umplified many years ago. That experience was one of the motivations for the current work.
In addition to classes, interfaces and generalizations available in object oriented languages, Umple allows software developers to specify:\\
\begin{enumerate}
 \item 	\textbf{Associations}: As in UML, these specify the links between objects that will exist at run time. Umple supports enforcement of multiplicity constraints and manages referential integrity – ensuring that bidirectional references are consistently maintained in both directions \cite{UmpleAssociations}.
 \item 	\textbf{Attributes}: These abstract the concept of instance variables. They can have properties such as immutability, and can be subject to constraints, tracing, and hooks that take actions before or after they are changed \cite{UmpleAttributes}.
 \item \textbf{	State Machines}: These also follow UML semantics, and can be considered to be a special type of attributes, subject to events that cause transitions from one value to another. States can have entry or exit actions, nested and possibly parallel substates, and activities that operate in concurrent threads \cite{Badreddin2012_Thesis}.
 \item 	\textbf{Traits}: A trait is a partial description of a class that can be reused in several different classes, with optional renaming of elements. They can be used to describe re-usable custom patterns.
 \item 	\textbf{Patterns}: Umple currently supports the singleton and immutable patterns, as well as keys that allow generation of consistent code for hashing and equality testing.
 \item 	\textbf{Aspect Oriented Code Injection}: This allows injection of code that can be run before or after methods, including Umple-defined actions on attributes, associations and the elements of state machines. Such code can be used as preconditions and post-conditions or for various other purposes. Code can be injected into the API methods (those methods generated by Umple) as well as into user-defined methods. 
 \item 	\textbf{Tracing}:  A sublanguage of Umple called MOTL (Model-oriented tracing language) allows developers to specify tracing at the model level, for example to enabling understanding of the behavior of a complex set of state machines operating in multiple threads and class instances \cite{UmpleTracing}.
 \item 	\textbf{Constraints}: Invariants, preconditions and postconditions can be specified.
 \item 	\textbf{Concurrency}: Umple provides several mechanisms to allow concurrency to be specified easily, including active objects, queuing in state machines, ports, and the aforementioned state activities.
\end{enumerate}
The Umple compiler supports code generation for Java, PHP, Ruby, C++ as well as export to XMI and other UML formats. The compiler generates various types of methods including mutator, accessor, and event methods from the various Umple features. A mutator (e.g. set(), add()) method is a method used to control changes to a variable and an accessor (e.g. get()) method is the one used to return values of the variable. An event method triggers state change. An extended summary of the API generated by Umple from attributes, associations, state machines and other features can be found at \cite{UmpleAPI}. Umple can also generate diagrams, metrics, and various other self-documentation artifacts. Umple models can be created or edited using the UmpleOnline Web tool \cite{UmpleOnline}, the command line compiler or an Eclipse plugin. 

The umplification method discussed in this paper currently focuses on associations,  attributes and state machines with some generation of code injections. The next sub-sections introduce these Umple constructs in greater detail.

\subsection{Umple Attributes}
An Umple attribute is a property of an object. For instance, 
a Person object might have a \textit{name} and an \textit{address}. 
Depending on the properties that the attribute may possess, an attribute can be:
\subsubsection{Basic Attribute}
A basic attribute in Umple represents simple data and is composed of one of the Umple data types and the name of the attribute. As shown through Tables \ref{table:apiAttrs1} and \ref{table:apiAttrs2}, the implications on code generation include a parameter in the constructor and a simple set and get methods to manage access to the attribute. The String datatype in umple is the default type, when no type is specified. 	The example below shows multiple attributes having different (umple) datatypes.

\vspace{\baselineskip}
\begin{lstlisting}[style=umplePlain]
class Demo 
{
  name; // String type
  Integer i;
  Float flt;
  String str;  
  Double dbl;
  Boolean bln;
  Date dte; 
  Time tme;
}
\end{lstlisting}

\subsection{Immutable Attribute}
An immutable attribute is the one that does not change during the lifetime of the class. The resulting base language code (e.g. Java) for an immutable attribute would be the same as the basic attribute implementation except that there would be not setter method generated. Briefly, a constructor argument is required so it can be set at construction time but it cannot be changed after since no setter is generated. The syntax for an immutable attribute is shown below. In this example, the \textit{studentId} must be initialized during construction and cannot changed after it. 
\vspace{\baselineskip}
\begin{lstlisting}[style=umplePlain]
class Student 
{
  Integer studentId;
}
\end{lstlisting}

\subsection{Defaulted}
A defaulted attribute is set in the constructor to the the default value, and can be reset to the default any time by calling a reset method (in this example resetName()). It can be also set to any other value using its setter method. 
\vspace{\baselineskip}
\begin{lstlisting}[style=umplePlain]
class School 
{
  String name="UOttawa";
}
\end{lstlisting}

\subsection{Unique}
The unique attribute guarantees its uniqueness within a particular class.
For instance, in the example below, in the set method of attribute 'name', prior to setting its value , we will check for uniqueness. 
\vspace{\baselineskip}
\begin{lstlisting}[style=umplePlain]
class Student 
{
  unique String name;
}
\end{lstlisting}

\subsection{Autounique}
The implementation of autounique attributes is very similar to the implementation of unique attributes presented in the previous sub-section. The main difference is that the autounique attribute is set in the constructor to the next available value. Autounique attributes must be of type Integer.
\vspace{\baselineskip}
\begin{lstlisting}[style=umplePlain]
class Student 
{
  autounique Integer studentId;
}
\end{lstlisting}

\subsection{Constant}
A constant (class level) attribute is identified using the \emph{const} keyword as illustrated below. A constant is associated with the type itself, rather than an \emph{instance} of the type.
\vspace{\baselineskip}
\begin{lstlisting}[style=umplePlain]
class Student 
{
  const Integer MAX_COURSES = 10;
}
\end{lstlisting}
\subsection{Array}
Umple supports attributes that might contain multiple values. The square brackets notation '[]' is used as shown below:
\vspace{\baselineskip}
\begin{lstlisting}[style=umplePlain]
class Student 
{
  String[] nickname;
}
\end{lstlisting}

In translating Umple attributes into object-oriented programming languages such as Java it is common to generate mutator and accessor methods. Tables \ref{table:apiAttrs1} and \ref{table:apiAttrs2} presents the list of accessor and mutator methods generated from Umple attributes. In Tables \ref{table:apiAttrs1} and \ref{table:apiAttrs2}, T is the type of the attribute (String if omitted) and z is the attribute name.	

\begin{table}[h]
\centering
\caption{API generated methods from Umple attributes}
\label{table:apiAttrs}
\begin{tabular}{lccc}
\toprule
\rowcolor[HTML]{BBDAFF}
\textbf{}               & \textbf{T getZ()}                                             & \textbf{boolean isZ()}     & \textbf{boolean equals(Object)} \\ \hline
      & returns the value                             & returns the value                                              & tests for reference equality    \\ \hline
\textbf{Basic}          & Yes                                                           & \begin{tabular}[c]{@{}l@{}}Yes;\\ if T is boolean\end{tabular} & No                              \\ \hline
\textbf{Initialized}    & Yes                                                           & \begin{tabular}[c]{@{}l@{}}Yes;\\ if T is boolean\end{tabular} & No                              \\ \hline
\textbf{Lazy}           & Yes                                                           & \begin{tabular}[c]{@{}l@{}}Yes;\\ if T is boolean\end{tabular} & No                              \\ \hline
\textbf{Defaulted}      & Yes                                                           & \begin{tabular}[c]{@{}l@{}}Yes;\\ if T is boolean\end{tabular} & No                              \\ \hline
\textbf{Immutable}      & Yes                                                           & \begin{tabular}[c]{@{}l@{}}Yes;\\ if T is boolean\end{tabular} & No                              \\ \hline
\textbf{Lazy immutable} & Yes                                                           & \begin{tabular}[c]{@{}l@{}}Yes;\\ if T is boolean\end{tabular} & No                              \\ \hline
\textbf{Autounique}     & \begin{tabular}[c]{@{}l@{}}Yes; \\ T always int.\end{tabular} & No                                                             & No                              \\ \hline
\textbf{Constant}       & No                                                            & No                                                             & No                              \\ \hline
\textbf{Internal}       & No                                                            & No                                                             & No                              \\ \hline
\textbf{Key}            & Yes                                                           & Yes                                                            & Yes                             \\ \hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{API generated methods (mutator) from Umple attributes}
\label{table:apiAttrs2}
\begin{tabular}{lcc}
\toprule
\rowcolor[HTML]{BBDAFF}
\textbf{}               & \textbf{boolean setZ(T)}                                  & \textbf{boolean resetZ()}                     \\ \hline
\textbf{Description}    & \multicolumn{1}{l}{mutates the attribute}                 & \multicolumn{1}{l}{restores original default} \\ \hline
\textbf{Basic}          & Yes                                                       & No                                            \\ \hline
\textbf{Initialized}    & Yes                                                       & No                                            \\ \hline
\textbf{Lazy}           & Yes                                                       & No                                            \\ \hline
\textbf{Defaulted}      & Yes                                                       & Yes;                                          \\ \hline
\textbf{Immutable}      & No                                                        & No                                            \\ \hline
\textbf{Lazy immutable} & \begin{tabular}[c]{@{}c@{}}Yes;\\ only once.\end{tabular} & No                                            \\ \hline
\textbf{Autounique}     & No                                                        & No                                            \\ \hline
\textbf{Constant}       & No                                                        & No                                            \\ \hline
\textbf{Internal}       & No                                                        & No                                            \\ \hline
\textbf{Key}            & Yes                                                       & No                                            \\ \hline
\end{tabular}
\end{table}

\subsection{Umple Associations}

In Umple (UML) an association defines a relationship from a class to another class. Furthermore, it specifies which links such as references or pointers may exist at run time between the different instances of the classes.
More specifically, an Umple association is composed of the following information:

\begin{itemize}
\item \textbf{Associations Ends}: These are the classes involved in the relationship.
\item \textbf{Navigability:} The navigability determines whether or not the association can be accessed from the opposite end. The notation '--' is used when each class can access the linked objects of the other class and '-\textgreater{}' or '\textless{}-' to indicate that the navigation is possible in only one direction.
\item \textbf{Multiplicity:} These are the restrictions on the numbers of objects allowed in the relationship.
\item \textbf{Role names:} The roles names are used to clarify the relationship and avoid collision if two classes are associated in multiple ways. Role names are optional except in reflexive associations.
\end{itemize}

The following code segment illustrates an association between instances of classes \emph{School} and \emph{Person}. In this example, an instance of class School can be associated to zero or more instances of class Student. The 'isA' notation is used to denote an inheritance relationship between the classes (Student is a subclass of Person). 
\vspace{\baselineskip}
\begin{lstlisting}[style=umplePlain]
class School {
 0..1 -- * Student student; //inline association
}
class Student {
  isA Person;
}
class Person { }
\end{lstlisting}

Alternatively, in addition to showing an association embedded in one of the associated classes, it is also possible to show an association independently. 
\vspace{\baselineskip}
\begin{lstlisting}[style=umplePlain]
class School {
}
class Student {
  isA Person;
}
class Person { }

association {
 0..1 School -- * Student student;
}
\end{lstlisting}

Tables \ref{table:apiAssocs1} and \ref{table:apiAssocs2} present the list of accessor and mutator methods generated from Umple associations. In Tables \ref{table:apiAttrs1} and \ref{table:apiAttrs2}, X is the name of the current class, W is the name of the class at the other association end and r is a role name used when referring to W.

\subsection{Umple State Machines}

\subsection{Code Injections}
Code injections are used to insert certain code statements \textbf{before} or \textbf{after} various Umple-defined actions on attributes, associations and (components of) state machines. Using \textbf{before} statements allows you to enforce preconditions and \textbf{after} statements to enforce postconditions. Code injections (after and before statements) can be added into the constructor and into the API generated methods such as \textit{getX, setX, addX, removeX, getXs, numberOfXs, indexOfX}, where X is the name of the attribute or association.

\begin{lstlisting}[style=umpleOut,label={lst:codeInjection},caption=A code injection into the constructor]
class Operation {  
  const Boolean DEBUG=true;  
  query;  
  before constructor {  
    if (aQuery == null)  
    {  
      throw new RuntimeException("Please provide a valid query");  
    }  
  }  
  after constructor {  
    if (DEBUG) { System.out.println("Created " + query); }  
  }  
}  
\end{lstlisting}

The following gives details of the above:\\
\underline{Line 2.} Declares a constant (static final in Java).  \\
\underline{Line 3.} Declares a simple (String) attribute.   	 \\
\underline{Line 4-9.} Declares a code injection to be inserted at the beginning of the constructor.  \\
\underline{Line 10-12.} Declares a code injection to be inserted at the end of the constructor.      \\

The code in Listing \ref{lst:codeInjection} generates the following (Java) constructor:

\begin{lstlisting}[style=java]
public Operation(String aQuery)
{
  if (aQuery == null)  
  {  
    throw new RuntimeException("Please provide a valid query");  
  }
  query = aQuery;
  if (DEBUG) { System.out.println("Created " + query); }
} 
\end{lstlisting}



\section{Reverse Engineering}

In the following chapter, we will describe the core concept of this thesis, the umplification technique, a model-to-model transformation technique that aims at incrementally transforming base language code into Umple code. Later, we will discuss which of the above languages proved most useful for umplification.
