\chapter{Conclusions and Contributions}
\lhead{\emph{\leftmark}}  % Set the left side page header to 
In this thesis we presented our reverse engineering approach called Umplification and the corresponding prototype tool, the Umplificator. Umplification is the process of transforming step-by-step a base language program to an Umple program. The major advantages, compared to other approaches, are the concept of incrementality and the mapping rules, which we in-tend to make general-purpose and easy to modify and add.  
We presented some evaluation results showing that our approach and its current implementation are effective and efficient enough to be applied in the future to real systems. 
Key contributions of this work are expected to be the following:
\begin{enumerate}
\item The overall concept of umplification
\item An understanding of how umplification compares with other reverse engineering techniques (incrementality, minimal adjustment of code to prevent disruption)
\item The Umplificator tool itself
\item Case studies of Umplification, demonstrating strengths, weaknesses and opportunities, as well as hopefully demonstrating that the resulting system is easier to under-stand and has less code.
\item Transformation patterns for (mapping rules) Umplification and the language for ex-pressing these. These should be general-purpose and easily modifiable to allow future researchers, and even end users, to add to them.
\item Detection of associations (of all different types) and state machines in a body of code. There is little successful work in this area in the literature.
\end{enumerate}

	As a future work, we plan to apply the approach to other open source systems, improve the mapping rules, improve the technology to allow Umple code to be input and add support for dynamic analysis for cases in which static analysis and parsing of the code is not enough to capture all the possible umplifiable concepts that can be derived from a program. We also want to integrate mapping rules for state machines and some popular soft-ware design patterns.

