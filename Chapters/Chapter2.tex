\lhead{\emph{\leftmark}}  % Set the left side page header to "Abbreviations"
\chapter{Background}

This chapter presents the required background knowledge for readers to fully understand the following chapters. We introduce the Umple language and we present the most important concepts about model-to-model transformations and some of the most relevant reverse engineering techniques. 
\section{Umple Modeling Language}

Umple [3] is an open-source textual modeling and programming language that adds UML abstractions to base programming languages including Java, PHP, C++ and Ruby.\\
Umple has been designed to be general purpose and has UML class diagrams and UML state diagrams as its central abstractions. It has state-of-the art code generation and can be used incrementally, meaning that it is easy for developers to gradually switch over to modeling from pure programming. Umple was designed for modeling and developing large systems and for teaching modeling [8]. Umple is written in itself – the original java version was manually umplified many years ago. That experience was one of the motivations for the current work.
In addition to classes, interfaces and generalizations available in object oriented lan-guages, Umple allows software developers to specify:\\
\begin{enumerate}
 \item 	\textbf{Associations}: As in UML, these specify the links between objects that will exist at run time. Umple supports enforcement of multiplicity constraints and manages referential in-tegrity – ensuring that bidirectional references are consistently maintained in both direc-tions.
 \item 	\textbf{Attributes}: These abstract the concept of instance variables. They can have properties such as immutability, and can be subject to constraints, tracing, and hooks that take actions be-fore or after they are changed.
 \item \textbf{	State Machines}: These also follow UML semantics, and can be considered to be a special type of attributes, subject to events that cause transitions from one value to another. States can have entry or exit actions, nested and possibly parallel substates, and activities that operate in concurrent threads.
 \item 	\textbf{Traits}: A trait is a partial description of a class that can be reused in several different classes, with optional renaming of elements. They can be used to describe re-usable custom patterns.
 \item 	\textbf{Patterns}: Umple currently supports the singleton and immutable patterns, as well as keys that allow generation of consistent code for hashing and equality testing.
 \item 	Aspect Oriented Code Injection: This allows injection of code that can be run before or after methods, including Umple-defined actions on attributes, associations and the ele-ments of state machines. Such code can be used as preconditions and post-conditions or for various other purposes. Code can be injected into the API methods (those methods generated by Umple) as well as into user-defined methods. 
 \item 	\textbf{Tracing}:  A sublanguage of Umple called MOTL (Model-oriented tracing language) al-lows developers to specify tracing at the model level, for example to enabling understand-ing of the behavior of a complex set of state machines operating in multiple threads and class instances [9].
 \item 	\textbf{Constraints}: Invariants, preconditions and postconditions can be specified.
 \item 	\textbf{Concurrency}: Umple provides several mechanisms to allow concurrency to be specified easily, including active objects, queuing in state machines, ports, and the aforementioned state activities.
The umplification method discussed in this paper currently focuses on associations and attributes, with some generation of Umple’s patterns and code injections. As future work it is planned to extend it to encompass other Umple features.
\end{enumerate}
The Umple compiler supports code generation for Java, PHP, Ruby, C++ as well as ex-port to XMI and other UML formats. The compiler generates various types of methods in-cluding mutator, accessor, and event methods from the various Umple features. A mutator (e.g. set(), add()) method is a method used to control changes to a variable and an accessor (e.g. get()) method is the one used to return values of the variable. An event method triggers state change. An extended summary of the API generated by Umple from attributes, associa-tions, state machines and other features can be found at [10]. Umple can also generate dia-grams, metrics, and various other self-documentation artifacts. Umple models can be created or edited using the UmpleOnline Web tool [11], the command line compiler or an Eclipse plugin. 
In the following chapter, we will describe the core concept of this thesis proposal, the umplification technique, a model-transformation technique that aims at incrementally trans-forming base language code into Umple code. Later, we will discuss which of the above lan-guages proved most useful for umplification.


\section{Reverse Engineering}